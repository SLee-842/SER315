# Deliverable 2

### Team Name
KoelnerDomspatzen

### Team Members
Brynn Ayers, Nathan Jordan, Stephen Lee, Brandon Navarrete, Tamara Sopoyeva

## Team Reflection

### Current Progress
- 

### Areas We Excelled
- 

### Areas of Improvement
- 

### Problems Faced
- 

### Changes to Next Iteration
- 

### Screencast URL
[Youtube Link to KoelnerDomspatzen's Deliverable Two (Update Me)](UpdateMe)

## Individual Reflection

>### Brynn Ayers
>**Contributions:** 
>
>**Reflection:** 

>### Nathan Jordan
>**Contributions:** 
>
>**Reflection:** 

>### Stephen Lee
>**Contributions:** Created Deliverable 2 template, updated Review section to include Instructor and Peer feedback, reorganized Deliverable 1 section to be consistant with the Project document, simplified the Use Case diagram, created initial Activity diagram
>
>**Reflection:**

>### Brandon Navarrete
>**Contributions:** 
>
>**Reflection:** 

>### Tamara Sopoyeva
>**Contributions:** 
>
>**Reflection:** 

## Meeting Overview

### Summary of Meetings


### Dates 


### Duration


### Atendees


### Meeting Minutes

## Update to Deliverable 1

### Class Diagram
#### Actors  

(From Requirements Document)  

- **Racer** – signs up, purchases license, registers for races, leaves reviews.  
- **Organizer** – creates races, manages stages, sets limits, enters results.  
- **Administrator** – manages accounts, licenses, and overall system settings.  

---

#### Core Classes  
(Domain-focused, directly from requirements)  

- **User** (abstract base class for Racer, Organizer, Administrator)  
- **Racer**  
- **Organizer**  
- **Administrator**  
- **Race**  
- **License**  
- **Registration** (represents a Racer registering for a Race)  
- **Result** (captures race outcomes and podium information)  
- **Review** (Racer feedback about a Race)  

---

#### Supporting System Classes  
(Implied, not explicitly in requirements but needed for real-world system design)  

- **AccountManager** (handles authentication and account lifecycle)  
- **PaymentProcessor** (handles credit card transactions for licenses)  
- **NotificationService** (notifies Racers of category upgrades or race information)  
- **DataRepository** (central persistence gateway for races, results, and users)  
- **UIController** (manages interaction between system logic and user interface)  


```mermaid
classDiagram
  direction TB

  %% ========= Core Users =========
  class User {
    <<abstract>>
    +id: UUID
    +name: String
    +email: String
  }
  class Racer {
    +currentCat: Category
    +hasValidLicense(on: Date): bool
  }
  class Organizer {
  }
  class Administrator {
  }

  User <|-- Racer
  User <|-- Organizer
  User <|-- Administrator

  %% ========= Licensing =========
  class License {
    +licenseId: String
    +validFrom: Date
    +validTo: Date
    +categoryAtIssue: Category
    +isValid(on: Date): bool
  }

  class Category {
    <<enumeration>>
    CAT5
    CAT4
    CAT3
    CAT2
    CAT1
  }

  Racer "1" o-- "0..1" License : holds
  Racer --> Category : current

  %% ========= Races & Stages =========
  class Race {
    +raceId: UUID
    +name: String
    +date: Date
    +miles: float
    +route: String
    +participantLimit: int
    +registrationDeadline: Date
    +official: bool
  }

  class RaceType {
    <<abstract>>
  }
  class RoadRace {
  }
  class CriteriumRace {
  }
  class TimeTrialRace {
  }
  class GravelRace {
  }

  RaceType <|-- RoadRace
  RaceType <|-- CriteriumRace
  RaceType <|-- TimeTrialRace
  RaceType <|-- GravelRace

  Race --> RaceType : type
  Race "1" *-- "0..*" Stage : contains

  class Stage {
    +stageId: UUID
    +name: String
    +distanceMiles: float
    +sequence: int
  }

  %% ========= Registration =========
  class Registration {
    +registrationId: UUID
    +createdAt: DateTime
    +status: RegStatus
  }

  class RegStatus {
    <<enumeration>>
    PENDING
    CONFIRMED
    CANCELLED
  }

  Racer "1" -- "0..*" Registration : makes
  Race  "1" -- "0..*" Registration : receives

  %% ========= Results =========
  class Result {
    +resultId: UUID
    +position: int   %% 1=gold, 2=silver, 3=bronze
    +timeSec: int
    +podium(): bool
  }

  Stage "1" -- "0..*" Result : has
  Racer "1" -- "0..*" Result : earns

  %% ========= Upgrade Policy =========
  class UpgradePolicy {
    <<service>>
    +shouldUpgrade(r: Racer): bool
    +applyUpgrade(r: Racer): void
  }

  UpgradePolicy ..> Result : counts podiums
  UpgradePolicy ..> Racer : updates category

  %% ========= Reviews =========
  class Review {
    +reviewId: UUID
    +rating: int  %% 1..5
    +comment: String
    +createdAt: DateTime
  }

  Racer "1" -- "0..*" Review : writes
  Race  "1" -- "0..*" Review : receives

  %% ========= Notifications =========
  class Notification {
    +notificationId: UUID
    +message: String
    +sentAt: DateTime
  }

  Notification ..> Racer : "upgrade notice"

```

>**NOTE:** Original class diagram was generated by ChatGPT but edited to better suit our design principles. See Appendix reference 1 for the AI promt.

### Use Case Diagram

```mermaid
---
config:
  layout: elk
---
flowchart LR
 subgraph RMS["Race Managment System"]
    direction LR
        createRace(["create race"])
        manageRaces(["manage races"])
        manageStages(["manage stages"])
        manageRegistrationLimits(["manage registration limits"])
        raceSignUp(["sign up for a race"])
        purchaseLicense(["purchase license"])
        reviewRaces(["review races"])
        manageUsers(["manage user accounts"])
        manageLicenses(["manage licenses"])
        manageSystem(["manage system setting"])
        addCreditCard([add credit card info])
        signUp([sign up])
        upgradeCategory([upgrade category])
        recordResults([record race results])
        notifyRacer([notify racer])
  end
    Organizers["Organizers"] --- createRace & manageRaces & recordResults
    Racers["Racers"] --- raceSignUp & purchaseLicense & reviewRaces
    Administrators["Administrators"] --- manageUsers & manageLicenses & manageSystem
    createRace -. &lt; include &gt; .-> manageStages & manageRegistrationLimits
    manageStages -. &lt; extend &gt; .-> manageRaces
    manageRegistrationLimits -. &lt; extend &gt; .-> manageRaces
    raceSignUp -. &lt; include &gt; .-> purchaseLicense
    purchaseLicense -. &lt; include &gt; .-> addCreditCard
    addCreditCard -. &lt; include &gt; .-> signUp
    recordResults --- upgradeCategory
    upgradeCategory -. &lt; include &gt; .-> notifyRacer

```

### Design Principles  

We plan to apply the following design principles to guide the development of the bike racing registration system.  

*(Note: Not being stated below does not mean we will avoid other common strategies or principles; these are simply the primary ones we are highlighting for Deliverable 1.)*  

   #### Single Responsibility Principle (SRP)  
  Each class will have a single, clear purpose.  
  **Example:** The `License` class will only manage license attributes (ID, category, expiration) rather than race registration or payment details.  

   #### Open/Closed Principle (OCP)  
  The system should be open for extension but closed for modification.  
  **Example:** The `Race` class should support new race types (road, gravel, time trial, etc...) without requiring changes to its core design, allowing future extensions through subclasses or composition.  

   #### Don’t Repeat Yourself (DRY)  
  Shared logic will be centralized to prevent duplication.  
  **Example:** Login and account management will be handled in the base `User` class, avoiding repeated code in `Racer`, `Organizer`, and `Administrator`.  

   #### Keep It Simple (KISS)  
  The design will prioritize simplicity and avoid unnecessary complexity.  
  **Example:** Category upgrades will follow a direct rule (*five podium finishes = one category promotion*) rather than adding complicated point systems *(as stated in the requirements documentation).*  

### Design Constraints  

We have identified our constraints from two perspectives: **user/problem-side** and **technical/stack-side**.  

#### User / Problem-Side Constraints  

- **Licensing Requirement** *(Requirements Document, p.1)*  
  Racers must purchase a valid license to register for official races.  
  Licenses are valid for one year and tied to the racer’s current category.  

- **Category System** *(Requirements Document, p.1–2)*  
  Racers are sorted into categories 5–1 (5 = beginner, 1 = elite).  
  Racers must only compete in races that match their current category.  
  Racers are promoted one category after five podium finishes (1st, 2nd, 3rd).  

- **Race Setup Rules** *(Requirements Document, p.2)*  
  Every race must offer all categories (5–1).  
  Each race has a date, type, distance, route, registration deadline, and participant cap.  
  Official races count toward category upgrades; unofficial races do not.  

- **Race History Persistence** *(Requirements Document, p.2)*  
  The system must keep a permanent record of races, results, and reviews.  
  Racer history must remain consistent across sessions (no data loss).  

---

#### Technical / Stack-Side Constraints  

- **Programming Language: Java** *(Project Document, p.3 Deliverable 3/4)*  
  All implementation will be done in Java using object-oriented design.  


- **Deliverable Guidelines** *(Project Document, p.3–4)*  
  Early deliverables require UML diagrams and use case diagrams.  
  Future deliverables include architecture design, activity diagram, and UI sketches.  
  The final deliverable requires a functional system but does not require a full graphical user interface.  


- **Scalability & Extensibility** *(Project Document, learning objectives)*  
  The system should support design principles like SRP and OCP to allow new race types without redesign.  
  Each deliverable (1–4) expects maintaining and updating previous work.  


- **Data Management** *(Requirements Document, p.2)*  
  The system must persist race history, racer accounts, licenses, and results.  
  Persistence ensures that category upgrades and reviews are accurate over time.  

## Architectural Design
![Architecture Diagram](https://github.com/SLee-842/SER315/blob/main/resources/images/architecture-breakdown.png)
|:--:|
| **Figure 1.** Layered Architecture for Bike Racing Registration System |


## Presentation Layer (<span style="color:red">CLOSED</span>)
**Nodes:** Racer, Organizer, Administrator (actors) and UIController  

**Responsibility:** Provides the user interface for all actors to interact with the system. Captures input such as race registration, entering results, and managing licenses, then forwards requests to the Business Layer.  

**Closed because:** It only communicates with the Business Layer. Preventing direct access to Services or Persistence ensures all interactions follow defined workflows.  

---

## Business Layer (<span style="color:red">CLOSED</span>)
**Nodes:** Race, Registration, License, Result, Review, UpgradePolicy  

**Responsibility:** Encapsulates the core domain logic including race management, registration validation, license checks, result recording, category upgrades, and reviews. Ensures rules such as racers must hold a valid license or five podium finishes equal a promotion.  

**Closed because:** All business rules must be executed here before calling Services or Persistence. This enforces Single Responsibility and avoids bypassing business validation.  

---

## Services Layer (<span style="color:green">OPEN</span>)
**Nodes:** AccountManager, NotificationService, PaymentProcessor  

**Responsibility:** Provides reusable shared services across the system. Handles authentication, notifications such as upgrade emails, and payments for licenses.  

**Open because:** Multiple layers may need to use services directly. For example, the Business Layer calls PaymentProcessor for registrations, while Presentation could directly access NotificationService in future extensions. Marking this layer open supports extensibility without requiring deep changes to other layers which aligns with OCP.  

---

## Persistence Layer (<span style="color:red">CLOSED</span>)
**Node:** DataRepository  

**Responsibility:** Manages all data persistence operations by translating business objects into queries and ensuring reliable storage and retrieval. Provides a single entry point to the database, keeping storage logic consistent.  

**Closed because:** Only the Business Layer and Services Layer can call into it. Presentation cannot access the database directly. This avoids data corruption and enforces encapsulation.  

---

## Database Layer (<span style="color:red">CLOSED</span>)
**Node:** Database (Users, Races, Licenses, Results, Reviews)  

**Responsibility:** Physical storage of all system entities. Ensures long-term persistence of race history, licenses, results, and reviews.  

**Closed because:** It is strictly internal and only the Persistence Layer can access it. Direct access from upper layers would break data integrity and bypass validation.  

## Activity Diagram

![Activity Diagram](https://github.com/SLee-842/SER315/blob/main/resources/images/ActivityDiagram.png)
|:--:|
| **Figure 2.** Activity Diagram for `Enter Race Results`|

## UI Sketch

## Review Section

**Instructor Feedback** 
- The instructor would like to be updated on our progress streamlining our collaboration tools (i.e. GitHub)
- Including contributions and reflections in the individual feedback section was a positive choice
- GitHub while primarily used for coding, was a good choice for team collaboration
- Good choice in design principles
- The Design Constraints section should be more focused on security, reliability etc.
- Our document was not in the order specified by the Project document
- Our Class diagram is hard to read, recommends cleaning it up and avoiding crossing lines
- Our Class diagram included a class without any relation
- Notes declairing AI usage was good
- Our Use Case diagram is overly detailed for a high level diagram, recommends simplifying
- Would like more details on the changes made to the AI generated diagrams

**Peer Feedback** 
- Expanding upon OCP and DRY principles would be benificial, specifically adding examples of how they could be applied
- Make relationships between supporting classes more explicit
- Diagram images are too small and hard to read
- Strong foundation

**Changes Made**
- Reorganized Deliverable 1 sectioon to better allign with the Project Document
- Simplified the Use Case diagram

## Appendix

1. ![ChatGPT Prompt for base class diagram](https://github.com/SLee-842/SER315/blob/main/resources/images/AI%20Propmt_ChatGPT_Class%20Diagram.png)
